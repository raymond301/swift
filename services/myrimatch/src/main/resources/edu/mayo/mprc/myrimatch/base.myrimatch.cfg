# Controls the number of charge states that MyriMatch will handle during all stages of the program.
# It is especially important during determination of charge state (see DuplicateSpectra for more information).
NumChargeStates = 4

# The output of a MyriMatch job will be an identification file for each input file.
# The string specified by this parameter will be appended to each output filename.
# It is useful for differentiating jobs within a single directory.
OutputSuffix = ""

# MyriMatch can write identifications in either "mzIdentML" or "pepXML" format.
OutputFormat = "pepXML"

# Specifies the FASTA protein database to be searched.
ProteinDatabase = ""

# Specifying a decoy prefix enables MyriMatch to know if it is making a target or a decoy comparison for each PSM.
# If the protein database has proteins that begin with DecoyPrefix, then those proteins are decoys.
# If not, decoy proteins are created on-the-fly by reversing each target protein in the database
# (so there is one decoy protein per target protein). The automatic reversal (as well as the ability to distinguish
# between target and decoy comparisons) can be disabled by setting the DecoyPrefix to the empty string ("").
DecoyPrefix = "rev_"

# A semicolon-delimited list of filters applied to spectra as it is read in.
# Supported filters are defined by ProteoWizard.
#
# See http://forge.fenchurch.mc.vanderbilt.edu/scm/viewvc.php/*checkout*/trunk/doc/index.html?root=myrimatch
# for more information.
#
# If no chargeStatePredictor is specified, a default one will be added like:
# "chargeStatePredictor false <NumChargeStates> 2 0.9"
spectrumListFilters = "peakPicking false 2-; chargeStatePredictor false 4 2 0.9"

# In order to maximize the effectiveness of the MVH scoring algorithm, an important step in preprocessing the
# experimental spectra is filtering out noise peaks. Noise peaks are filtered out by sorting the original peaks
# in descending order of intensity, and then picking peaks from that list until the cumulative ion current of the
# picked peaks divided by the total ion current (TIC) is greater than or equal to this parameter. Lower percentages
# mean that less of the spectrums total intensity will be allowed to pass through preprocessing. See the section on
# Advanced Usage for tips on how to use this parameter optimally.
TicCutoffPercentage = 0.98

# A generated sequence candidate is only compared to an experimental spectrum if the candidates mass is within
# this tolerance of the experimental spectrum's precursor mass. The units ("daltons" or "ppm") must be provided as
# well as the magnitude. The actual tolerance used for the search is calculated by multiplying the tolerance by
# the charge state, so this parameter should be set to the tolerance that is desired for +1 spectra.
# At the default value, the precursor mass tolerances are 1.5, 3, and 4.5 Da for the first three charge states,
# respectively. 
AvgPrecursorMzTolerance = "1.25m/z"

# A generated sequence candidate is only compared to an experimental spectrum if the candidates
# mass is within this tolerance of the experimental spectrum's precursor mass.
# The units ("daltons" or "ppm") must be provided as well as the magnitude.
# The actual tolerance used for the search is calculated by multiplying the tolerance by the charge state, so
# this parameter should be set to the tolerance that is desired for +1 spectra. At the default value,
# the precursor mass tolerances are 10, 20, and 30 ppm for the first three charge states, respectively. 
MonoPrecursorMzTolerance = "10ppm"

# Sometimes a mass spectrometer will pick the wrong isotope as the monoisotope of an eluting peptide.
# When using narrow tolerances formonoisotopic precursors, this can cause identifiable spectra to be missed.
# This parameter defines a set of isotopes (0 being the instrument-called monoisotope) to try as
# the monoisotopic precursor m/z. To disable this technique, set the value to "0".
MonoisotopeAdjustmentSet = "[-1,2]"

# This parameter controls the automatic selection of precursor mass type.
# For data from Thermo instruments, using the "auto" setting on a RAW, mzML, or mz5 file will automatically choose
# monoisotopic or average mass values (and the corresponding precursor tolerance). For other instruments or older
# data formats, the "mono" or "avg" tolerance should be set explicitly.
PrecursorMzToleranceRule = auto

# This parameter controls how much tolerance there is on each side of the calculated m/z when looking for an ion
# fragment peak during candidate scoring. The units ("daltons" or "ppm") must be provided as well as the magnitude.
FragmentMzTolerance = "10ppm"

# This parameter determines which ion series are used to build the theoretical spectrum for each candidate peptide.
# Possible values are:
# CID: b, y
# ETD: c, z*
# manual: user-defined (a comma-separated list of [abcxyz] or z* (z+1), e.g. manual:b,y,z
FragmentationRule = "manual:a,b,y"

# If true, MyriMatch will automatically choose the fragmentation rule based on the activation type of each MSn spectrum.
# This allows a single search to handle CID and ETD spectra (i.e. an interleaved or decision tree run).
# If false or if the input format does not specify the input format then FragmentationRule is used (see above).
FragmentationAutoRule = true

# If a residue (or multiple residues) should always be treated as having a modification on their natural mass,
# set this parameter to inform the search engine which residues are modified. Residues are entered into this
# string as a space-delimited list of pairs. Each pair is of the form:
# <AA residue character> <mod mass>
#
# Thus, to treat cysteine as always being carboxymethylated, this parameter would be set to something like the string:
# "C 57"
StaticMods = ""

# Note: avoid using the "#" symbol in a configuration file since it begins a comment section.
# Using the "#" symbol in a command-line override works fine.
#
# In order to search a database for potential post-translational modifications of candidate sequences,
# the user must configure this parameter to inform the search engine which residues may be modified.
# Residues that are modifiable are entered into this string in a space-delimited list of triplets.
# Each triplet is of the form:
# <AA motif> <character to represent mod> <mod mass>
#
# Thus, to search for potentially oxidized methionines and phosphorylated serines,
# this parameter would be set to something like the string:
# "M * 15.995 S $ 79.966"
#
# The AA motif can include multiple residues, and the peptide termini are represented by opening
# "(" and closing ")" parentheses for the N and C termini, respectively. For example, an N terminal
# deamidation of glutamine may be specified by the string:
# "(Q ^ -17"
#
# If the last residue in the motif is not the residue intended to be modifiable, then use an exclamation mark to
# indicate that the residue preceding the mark is the modifiable residue. Using the previous example,
# "(Q! ^ -17" is an equivalent way to specify it. Another example would be specifying
# the demidation of asparagine when it is N terminal to a glycine, which might look like:
# "N!G @ -17"
#
# Another possibility is to specify a block of interchangeable residues in the motif, which is supported
# by the "[" and "]" brackets. For example, to specify a potential phosphorylation on any serine,
# threonine, or tyrosine, use the string:
# "[STY] * 79.966"
#
# The "{" and "}" brackets work in the opposite way as the "[" and "]" brackets, i.e. "{STY} * 79.966"
# specifies a potential phosphorylation on every residue EXCEPT serine, threonine, or tyrosine.
# Both kinds of brackets can be combined with the exclamation mark, in which case the exclamation mark should
# come after the block (because the block counts as a single residue).
# Using the previous example, "[STY]! * 79.966" is an equivalent way to specify it.
#
# Using the negative multi-residue brackets is the best way to indicate the "any residue except" concept,
# and it works on single residues as well. For example, to specify a mod on lysine except when it is
# at the C terminus of a peptide, use something like the string "K!{)} # 144".
# Another example is specifying the cleavage-blocking homoserine mod in a CnBr digest
# when a serine or threonine is C terminal to a methionine:
# "M![ST] * -29.99"
#
# Note that it is not currently possible to specify (for example) the non-cleavage-blocking homoserine lactone
# mod in a CnBr digest, because the motif would extend outside of the peptide sequence itself.
# In the future a string like "M!){ST} * -17" might work for that, but for now, if "(" is used
# it must be the first character in the motif, and likewise if ")" is used it must be the last character in a motif.
DynamicMods = ""

# This parameter sets the maximum number of modified residues that may be in any candidate sequence.
MaxDynamicMods = 3

# This parameter sets the maximum rank of peptide-spectrum-matches to report for each spectrum.
# A rank is all PSMs that score the same (common for isobaric residues and ambiguous modification localization).
# MyriMatch may report extra ranks in order to ensure that the top target match and top decoy match from
# each digestion specificity (full, semi, non) is reported.
MaxResultRank = 2

# This important parameter allows the user to control the way peptides are generated from the protein database.
# It can be used to configure the search on tryptic peptides only, on non-tryptics, or anything in between.
# It can even be used to test multiple residue motifs at a potential cleavage site. This parameter describes
# which amino acids are valid on the N and C termini of a digestion site. The parameter is specified in PSI-MS
# regular expression syntax (a limited Perl regular expression syntax). 
#
# See http://www.ebi.ac.uk/ontology-lookup/browse.do?ontName=MS&termId=MS:1001045&termName=cleavage%20agent%20name
# for a complete list of supported proteases
CleavageRules = "(?<=K)(?!P)"

# By default, when generating peptides from the protein database, a peptide must start and end at a valid cleavage site.
# Setting this parameter to 0 or 1 will reduce that requirement, so that neither terminus or only one terminus
# of the peptide must match one of the cleavage rules specified in the CleavageRules parameter.
# This parameter is useful to turn a tryptic digest into a semi-tryptic digest.
MinTerminiCleavages = 2

# By default, when generating peptides from the protein database, a peptide may contain any number of missed cleavages.
# A missed cleavage is a site within the peptide that matches one of the cleavage rules (refer to CleavageRules).
# Settings this parameter to some other number will stop generating peptides from a sequence if it contains
# more than the specified number of missed cleavages.
MaxMissedCleavages = 2

# When preprocessing the experimental spectra, any spectrum with a precursor mass that is less than the specified
# mass will be disqualified. This parameter is useful to eliminate inherently unidentifiable spectra from
# an input data set. A setting of 500 for example, will eliminate most 3-residue matches and clean up the
# output file quite a lot. In Daltons.
MinPeptideMass = 0

# When preprocessing the experimental spectra, any spectrum with a precursor mass that exceeds
# the specified mass will be disqualified. In Daltons.
MaxPeptideMass = 10000

# When digesting proteins, any peptide which does not meet or exceed the specified length will be disqualified.
MinPeptideLength = 5

# When digesting proteins, any peptide which exceeds this specified length will be disqualified.
MaxPeptideLength = 75

# Preprocessing spectra and scoring candidates may take a long time. A measure of progress through the protein
# database will be given on intervals that are specified by this parameter, measured in seconds.
StatusUpdateFrequency = 5

# Once a candidate sequence has been generated from the protein database, MyriMatch determines which spectra
# will be compared to the sequence. For each unique charge state of those spectra, a set of theoretical fragment
# ions is generated by one of several different algorithms.
#
# For +1 and +2 precursors, a +1 b and y ion is always predicted at each peptide bond.
#
# For +3 and higher precursors, the fragment ions predicted depend on the way this parameter is set.
# When this parameter is true, then for each peptide bond, an internal calculation is done to estimate the basicity
# of the b and y fragment sequence. The precursors protons are distributed to those ions based on that calculation,
# with the more basic sequence generally getting more of the protons. For example, when this parameter is true,
# each peptide bond of a +3 precursor will either generate a +2 bi and a +1 yi ion, or a +1 bi and a +2 yi ion.
# For a +4 precursor, depending on basicity, a peptide bond breakage may result in a +1 bi and a +3 yi ion, a +2 bi
# and a +2 yi ion, or a +3 bi and a +1 yi ion. When this parameter is false, however, ALL possible charge distributions
# for the fragment ions are generated for every peptide bond. So a +3 sequence of length 10 will always have theoretical
# +1 y5, +2 y5, +1 b5, and +2 b5 ions.
UseSmartPlusThreeModel = false

# Before beginning sequence candidate generation and scoring, MyriMatch will do a random sampling of the protein
# database to get an estimate of the number of comparisons that will be done by the job. The bigger the sample size,
# the longer this estimate will take and the more accurate it will be. Of course, if there are fewer proteins in
# the database than the sample size, all proteins will be used in the sampling and
# the number of comparisons will be exact.
ProteinSampleSize = 100

# If true, a Sequest-like cross correlation (xcorr) score will be calculated for the top ranking hits
# in each spectrum's result set.
ComputeXCorr = true

# Before scoring any candidates, experimental spectra have their peaks stratified into the number of intensity classes
# specified by this parameter. Spectra that are very dense in peaks will likely benefit from more intensity classes
# in order to best take advantage of the variation in peak intensities. Spectra that are very sparse will not
# see much benefit from using many intensity classes.
NumIntensityClasses = 3

# When stratifying peaks into a specified, fixed number of intensity classes, this parameter controls the size
# of each class relative to the class above it (where the peaks are more intense). At default values, if the best class,
# A, has 1 peak in it, then class B will have 2 peaks in it and class C will have 4 peaks.
ClassSizeMultiplier = 2

# This parameter sets a number of batches per node to strive for when using the MPI-based parallelization features.
# Setting this too low means that some nodes will finish before others (idle processor time), while setting it
# too high means more overhead in network transmission as each batch is smaller.
NumBatches = 50

# MyriMatch is designed to take advantage of (symmetric) multiprocessor systems by multithreading the database search.
# A search process on an SMP system will spawn one worker thread for each processing unit (where a processing
# unit can be either a core on a multi-core CPU or a separate CPU entirely). The main thread then generates a list of
# worker numbers which is equal to the number of worker threads multiplied by this parameter. The worker threads then
# take a worker number from the list and use that number to iterate through the protein list. It is possible that
# one thread will be assigned all the proteins that generate a few candidates while another thread is assigned all
# the proteins that generate many candidates, resulting in one thread finishing its searching early. By having
# each thread use multiple worker numbers, the chance of one thread being penalized for picking all the easy
# proteins is reduced because if it finishes early it can just pick a new number. The only disadvantage to this system
# is that picking the new number incurs some overhead because of synchronizing with the other worker threads that
# might be trying to pick a worker number at the same time. The default value is a nice compromise between incurring
# that overhead and minimizing wasted time.
ThreadCountMultiplier = 10

# If true, each process will use all the processing units available on the system it is running on.
UseMultipleProcessors = true